# 5-1 起動情報の受け取り
実は，bootpack.cにVRAMの番地や画面サイズを直に描いておくのはよろしくないです．
なんでかというと，これらの値は画面モードによって変わってしまいますし，画面モードの設定はasmhead.nasでやっていたのです．
なので，これらの値はasmhead.nasで画面モードを設定する時にどこかにメモしておいて，それを取り出して使うべきです．
で，これらの値は[0xff0]以降にメモしてあるのです(詳しくはasmhead.nasの最初の方を見て下さい)．

あと，背景を描画する部分は```init_screen```関数になりました．

# 5-2 構造体を使ってみる
asmhead.nasでメモした起動情報を一つ一つbinfo_なんとかというポインタ変数を作って番地を指定して読み出すのは面倒なので，構造体というものを使ってみます．

構造体というのは，新しい型のようなものを作ることができるC言語の機能です．
```
struct BOOTINFO {
	char cyls, leds, vmode, reserve;
	short scrnx, scrny;
	char* vram;
};
```
というようにすると，```BOOTINFO```という名前の構造体を定義できます．
そして，この構造体は```char```型の変数```cyls, leds, vmode, reserve```，
```short```型の変数```scrnx, scrny```，
```char*```型の変数```vram```を内部に持ちます．
このような構造体内部の変数のことをメンバ(変数)といいます．

この構造体を使うには，```struct BOOTINFO binfo;```のようにすると，```BOOTINFO```構造体の変数```binfo```ができます．
```struct BOOTINFO```が型のようなものというわけですね．

このようにして作った構造体は，普通の変数と同じように値を読んだり書いたりすることができます．
ただし，値の読み書きができるのは構造体自体ではなく構造体のメンバ変数です．
構造体変数からメンバ変数にアクセスするには```.```という演算子を使います．

まとめると，
```
struct BOOTINFO binfo;
binfo.scrnx = 300;
binfo.scrny = 200;
binfo.vram = 0xa0000;
```
というようなことができるわけです．
こうのように，構造体自体も，構造体のメンバ変数も普通の変数のように扱うことができます．

また，構造体変数は普通の変数と同じように使えるので，普通の変数と同じようにポインタも使えます．
```
struct BOOTINFO *binfo;
```
とすると，```BOOTINFO```構造体のポインタ変数(番地変数)```binfo```を作ることができます．

そして，asmhead.nasで起動情報は[0xff0]にメモしておいたのでした．
なので，あとはこのポインタ変数```binfo```にアドレスを設定してやればいいわけです．
```
binfo = (struct BOOTINFO *) 0x0ff0;
```
さて，構造体のポインタ変数にアドレスを設定したので，あとはここからメンバ変数の値を読み出して使っていけばOKですね．
ポインタ変数からそのアドレスが指す先の値を使うには，ポインタ変数に```*```を付ければよいのでした．
なので，```*binfo```が```BOOTINFO```構造体として扱えるはずです．
そして，構造体変数からメンバにアクセスするには```.```演算子を使うのでした．
よって，```(*binfo).scrnx```のようにすると，[0xff0]以降に並んでいる起動情報を```BOOTINFO```構造体として扱って，その中のscrnxメンバにアクセスできるわけですね．

で，こうすると```binfo_なんたら```とかいう変数をたくさん作って一々それにアドレスを設定して．．．とかいうことをやらずに済むわけです．
構造体バンザイですね．
