# 4-1 C言語からメモリに書き込みたい

はい，C言語がいい感じに使えるようになったので色々やっていこうと思います．
思うのですが，画面が真っ黒のままでは面白くないです．
というわけで画面に何か描きます．
画面に何か描くにはVRAMに何か書きこめばいいので，MOVすればいいわけです．

で，C言語で指定したメモリに何か書く方法なんですが，これがあの悪名高きポインタってやつなんですね．
なのでポインタは一旦置いておいて，ポインタ以外の方法を使います．
ではどうするのかというと，ようはMOVをすればいいので，MOVする関数をアセンブラで作ってそれを呼び出してやります．

これをやるのがnaskfunc.nasのwrite_mem8関数です．
ちなみに，今までスルーしてましたがC用の関数をアセンブラで作る場合には関数名の最初にアンダースコアをつけます．
Cで作った関数をコンパイルしてアセンブラになったところを見ると同じようになっています
(なお，C++だと名前マングリングというものがありこうはいきません)．

write_mem8では引数としてアドレスとデータを取っていますが，Cの関数で引数がどのように扱われるのかというと，
n番目の引数は```[ESP+ 4*n]```に格納されています(実はこれは32bitの時の話で，64bitになると最初の数個がレジスタだったりします)．

ようは第1引数をECXに入れて，第2引数をALに入れて，ECXの番地にALを入れているだけです．
単純ですね．

あとはこの関数を使ってVRAMに書き込めばいいわけです．
現在のモードでのVRAMのアドレスは0xa0000〜0xaffffなので，for文でループしてVRAMを15で埋め尽くしています．
この15というのは色の番号で，ここでは白なのでこれを実行すると真っ白になります．

# 4-2 しましま模様
画面が真っ白でも面白くないので，しましま模様を描いてみます．
まあ真っ白な画面を印刷しても印刷された時にただの真っ白になってしまうという筆者の都合もあったようですが()．

で，どうやってしましま模様にするかですが，AND演算を使っています．
ANDというのはそれぞれの(2進数の)桁についてどちらも1のときだけ1にして，それ以外の時は0にするという演算です．

これを使うと，特定のビットだけを取り出すことができます
(```A AND B```なら，AのうちBを1にしたビットだけが抽出される)．

じゃあ今回はどうしているのかというと，描画するデータを書き込むアドレスと0x0fのANDをとったものにしています．
0x0fは2進数にすると00001111なので，書き込むアドレスの下位4bitを取り出していることになります．

ここで，アドレスはfor文でループして1ずつ加算されていくので，下位4bitは0〜15(=0x0f=0b00001111)の範囲でループする，というわけです．
色番号0〜15で順番に描画されていき，結果的にしましま模様になるわけですね．


また，ANDの他にORやXORという演算もあります．
ORはどちらかが1なら1にする(特定のビットを1にする)，XORは特定のビットを反転させる演算です．

# 4-3 ポインタに挑戦
さて，4-1でwrite_mem8()という関数を作って指定のメモリに書き込んだ訳ですが，これはちゃんとC言語だけで書くことができます．
それにはポインタというものを使います．
ポインタはよく難しいと言われ，数多の初心者を殺してきたわけですが，実はアセンブラを先にやってしまうとそこまで難しいことではありません．


まず，```char* p;```という文があります．
これは```char*```という型の変数pを宣言しています．
```char```というのは```int```が32bit整数の型なのと同じように，8bitの型のことです．

となると，「```char```が8bitなのは分かったけど```char*```って何？」ってなりますよね．
このアスタリスクがついたものはなんなのかというと，```charのポインタ型```というものです．
ポインタ型，なんて言うからよく分からなくなるのですが，ポインタというのはメモリの番地のことです．アドレスです．
整理すると，```char*```というのは```8bitの変数の番地の型```ということですね．
まあこんなことを言っていても，実際に使ってみないとよく分からないです．使います．

```char* p;```でcharの番地の型の変数pを宣言したわけですが，このようなポインタ変数(=番地変数)というやつにはアドレス，つまり番地を入れることが出来るのです．
今回指定したい番地は変数i(=0xa0000〜0xaffff)に入っているので，pに代入します．
```p = i;```です．

ただ，残念ながらこれではコンパイラがwarningを出してしまいます．
なので，```p = (char*) i```のようにしてください．
この括弧はキャストというものです．
```i```はどうせ32bitの数値なのでそのままアドレスとして扱っても何の問題も無いだろうとは思う
(なのでwarningで済むとも言える)
のですが，C言語ではそういうことはできないのです．
あくまで```p```は```char*```型の変数であって，```int```という異なる型の変数である```i```を直接代入することはできないんです．
そこでキャストということをするのです．
キャストをすると，ある型の変数を一時的に別の型の変数として扱うことができます．
ここでいうと，```i```を```char*```型の変数として扱っている，というわけです．

これで番地が指定できましたが，今回はこの番地が指す先のメモリに色番号(=i & 0x0f)を代入したいのです．
これもポインタ変数を使って書くことができます．
ポインタ変数の前にアスタリスクをつけてやるのです．
今回で言うと```*p```ですね．
これは```p```に入っている番地の先のメモリのことになります．
なので，あとはこれに色番号を代入してやれば，指定した番地のメモリに色番号を代入したことになるわけです．

よって，```*p = i & 0x0f;```のようになります．


「変数の前にアスタリスクを付けたらその変数の番地のメモリになるなら```*i = i & 0x0f;```とかもできるの？」と思うかもしれませんが，そういうことはできません
(これは多分型の問題です．```int*```型が指す先は```int```型ですが，```int```型が指す先を求めても「う〜ん，そういう型はないよ」となってしまうわけです．また，typedefとかして新しい型を作ったとすると，それはアドレスに変換できるとは限りません．というか整数型でもない限りできないでしょう．なのでこういうことは全部ポインタを使ってやるのです)．


また，今回の場合```p```は```char```のポインタ型の変数で，```char```というのは8bitの型なので，これが指す先は8bitです．
こういうわけで，```*p = i & 0x0f;```は```MOV BYTE [p], (i & 0x0f)```のとなるわけです．


実際，bootpack.cをコンパイルしてnaskに変換したbootpack.nasを見てみると，```MOV BYTE [EDX],AL```となっています．
周辺のコードも読んでみると，EDXが```p```,ALが```i & 0x0f```に対応しているようです．


これでwrite_mem8の呼び出しコストが無くなったので，かなりいいかんじになりました．
write_mem8は金輪際使わないのでnaskfunc.nasから削除です．
