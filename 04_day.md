# 4-1 C言語からメモリに書き込みたい

はい，C言語がいい感じに使えるようになったので色々やっていこうと思います．
思うのですが，画面が真っ黒のままでは面白くないです．
というわけで画面に何か描きます．
画面に何か描くにはVRAMに何か書きこめばいいので，MOVすればいいわけです．

で，C言語で指定したメモリに何か書く方法なんですが，これがあの悪名高きポインタってやつなんですね．
なのでポインタは一旦置いておいて，ポインタ以外の方法を使います．
ではどうするのかというと，ようはMOVをすればいいので，MOVする関数をアセンブラで作ってそれを呼び出してやります．

これをやるのがnaskfunc.nasのwrite_mem8関数です．
ちなみに，今までスルーしてましたがC用の関数をアセンブラで作る場合には関数名の最初にアンダースコアをつけます．
Cで作った関数をコンパイルしてアセンブラになったところを見ると同じようになっています
(なお，C++だと名前マングリングというものがありこうはいきません)．

write_mem8では引数としてアドレスとデータを取っていますが，Cの関数で引数がどのように扱われるのかというと，
n番目の引数は```[ESP+ 4*n]```に格納されています(実はこれは32bitの時の話で，64bitになると最初の数個がレジスタだったりします)．

ようは第1引数をECXに入れて，第2引数をALに入れて，ECXの番地にALを入れているだけです．
単純ですね．

あとはこの関数を使ってVRAMに書き込めばいいわけです．
現在のモードでのVRAMのアドレスは0xa0000〜0xaffffなので，for文でループしてVRAMを15で埋め尽くしています．
この15というのは色の番号で，ここでは白なのでこれを実行すると真っ白になります．

# 4-2 しましま模様
画面が真っ白でも面白くないので，しましま模様を描いてみます．
まあ真っ白な画面を印刷しても印刷された時にただの真っ白になってしまうという筆者の都合もあったようですが()．

で，どうやってしましま模様にするかですが，AND演算を使っています．
ANDというのはそれぞれの(2進数の)桁についてどちらも1のときだけ1にして，それ以外の時は0にするという演算です．

これを使うと，特定のビットだけを取り出すことができます
(```A AND B```なら，AのうちBを1にしたビットだけが抽出される)．

じゃあ今回はどうしているのかというと，描画するデータを書き込むアドレスと0x0fのANDをとったものにしています．
0x0fは2進数にすると00001111なので，書き込むアドレスの下位4bitを取り出していることになります．

ここで，アドレスはfor文でループして1ずつ加算されていくので，下位4bitは0〜15(=0x0f=0b00001111)の範囲でループする，というわけです．
色番号0〜15で順番に描画されていき，結果的にしましま模様になるわけですね．


また，ANDの他にORやXORという演算もあります．
ORはどちらかが1なら1にする(特定のビットを1にする)，XORは特定のビットを反転させる演算です．

# 4-3 ポインタに挑戦
さて，4-1でwrite_mem8()という関数を作って指定のメモリに書き込んだ訳ですが，これはちゃんとC言語だけで書くことができます．
それにはポインタというものを使います．
ポインタはよく難しいと言われ，数多の初心者を殺してきたわけですが，実はアセンブラを先にやってしまうとそこまで難しいことではありません．


まず，```char* p;```という文があります．
これは```char*```という型の変数pを宣言しています．
```char```というのは```int```が32bit整数の型なのと同じように，8bitの型のことです．

となると，「```char```が8bitなのは分かったけど```char*```って何？」ってなりますよね．
このアスタリスクがついたものはなんなのかというと，```charのポインタ型```というものです．
ポインタ型，なんて言うからよく分からなくなるのですが，ポインタというのはメモリの番地のことです．アドレスです．
整理すると，```char*```というのは```8bitの変数の番地の型```ということですね．
まあこんなことを言っていても，実際に使ってみないとよく分からないです．使います．

```char* p;```でcharの番地の型の変数pを宣言したわけですが，このようなポインタ変数(=番地変数)というやつにはアドレス，つまり番地を入れることが出来るのです．
今回指定したい番地は変数i(=0xa0000〜0xaffff)に入っているので，pに代入します．
```p = i;```です．

ただ，残念ながらこれではコンパイラがwarningを出してしまいます．
なので，```p = (char*) i```のようにしてください．
この括弧はキャストというものです．
```i```はどうせ32bitの数値なのでそのままアドレスとして扱っても何の問題も無いだろうとは思う
(なのでwarningで済むとも言える)
のですが，C言語ではそういうことはできないのです．
あくまで```p```は```char*```型の変数であって，```int```という異なる型の変数である```i```を直接代入することはできないんです．
そこでキャストということをするのです．
キャストをすると，ある型の変数を一時的に別の型の変数として扱うことができます．
ここでいうと，```i```を```char*```型の変数として扱っている，というわけです．

これで番地が指定できましたが，今回はこの番地が指す先のメモリに色番号(=i & 0x0f)を代入したいのです．
これもポインタ変数を使って書くことができます．
ポインタ変数の前にアスタリスクをつけてやるのです．
今回で言うと```*p```ですね．
これは```p```に入っている番地の先のメモリのことになります．
なので，あとはこれに色番号を代入してやれば，指定した番地のメモリに色番号を代入したことになるわけです．

よって，```*p = i & 0x0f;```のようになります．


「変数の前にアスタリスクを付けたらその変数の番地のメモリになるなら```*i = i & 0x0f;```とかもできるの？」と思うかもしれませんが，そういうことはできません
(これは多分型の問題です．```int*```型が指す先は```int```型ですが，```int```型が指す先を求めても「う〜ん，そういう型はないよ」となってしまうわけです．また，typedefとかして新しい型を作ったとすると，それはアドレスに変換できるとは限りません．というか整数型でもない限りできないでしょう．なのでこういうことは全部ポインタを使ってやるのです)．


また，今回の場合```p```は```char```のポインタ型の変数で，```char```というのは8bitの型なので，これが指す先は8bitです．
こういうわけで，```*p = i & 0x0f;```は```MOV BYTE [p], (i & 0x0f)```のとなるわけです．


実際，bootpack.cをコンパイルしてnaskに変換したbootpack.nasを見てみると，```MOV BYTE [EDX],AL```となっています．
周辺のコードも読んでみると，EDXが```p```,ALが```i & 0x0f```に対応しているようです．


これでwrite_mem8の呼び出しコストが無くなったので，かなりいいかんじになりました．
write_mem8は金輪際使わないのでnaskfunc.nasから削除です．

# 4-4 ポインタの応用(1)
```p + i```番地のメモリは```*(p + i)```のように書くことができます．

# 4-5 ポインタの応用(2)
```*(p + i)```には```p[i]```という省略表現があります．
こう書くと配列のように思えますが，```p[i]```というのはあくまで```*(p + i)```の省略表現です．
なので，```*(p + i)```,```p[i]```,```i[p]```は全く同じ意味です．

# 4-6 色番号設定
さて，C言語からVRAMに書き込んで描画ができるようになったので，とりあえず色々描いてみたいわけなんです．
しかし，色の指定はどうすれば良いのでしょうか．
VRAMに指定の色番号を書けばその色が描画されますが，色と色番号がどう対応しているのか分かりません．
まあ0番が黒で15番は白ぐらいは決まっているんですが，それ以外はよく分かりません．
まあ調べる方法はあるので調べようと思えば調べられるのですが，面倒ですしそんなことをするよりは自分で色を設定して使いたいので，します．

色を設定する方法は，パレットという色番号と色(RGB)の対応表のようなものにに設定する，というものです．

パレットへのアクセス手順は[こちらのサイト](http://oswiki.osask.jp/?VGA )の「ビデオDAコンバータ」という項目を参照しましょう．

<details><summary>パレットのアクセスの手順</summary>
<ul>
<li>まず一連のアクセス中に割り込みなどが入らないようにする（たとえばCLI）。</li>
<li>0x03c8に設定したいパレット番号を書き込み、続いて、R、G、Bの順に0x03c9に書き込む。もし次のパレットも続けて設定したいのなら、パレット番号の設定を省略して、さらにRGBの順に0x03c9に書き込んでよい。</li>
<li>現在のパレット状態を読み出すときは、まず0x03c7にパレット番号を書き込んで、0x03c9を3回読み出す。これが順にR、G、Bになっている。これももし次のパレットも読み出したいときは、パレット番号の設定を省略してRGBの順に読み出してよい。</li>
<li>最初にCLIした場合は、最後にSTIする。<li>
</ul>
</details>

というわけで，これに従って色を設定していきます．

まず，割り込みを禁止しなければなりません．
割り込みというのはCPUがある処理をしている時になんらかのイベントの発生を検知して，いったん処理を中断して指定のイベントハンドラを実行する，みたいな機能です．
キーボード入力などの，いつ来るか分からない処理をするのに使われます．
まあ，割り込みはあとで細かくやるのでこれくらいにしますが，ようするに，パレットにアクセスしている途中にこの割り込みが発生すると困るので，パレットアクセスの前に割り込みを禁止しておいて，終わったら割り込みを許可する，みたいなことをしたいのです．
で，割り込みを禁止するのがCLI，許可するのがSTI命令というわけです．

だったらCLI,STIする関数```io_cli()```,```io_sti()```をアセンブラで書いて，一連の処理の前後に呼び出せばいいじゃないか，と思うわけなんですが，今回の```bootpack.c```の```set_palette()```関数ではそうなっていません．
まあもちろんそれでも動くんですが，今回は何故そうなっていないのかというと，処理が終わったら元々の割り込み許可状態に復元したいからです．
つまり，元々割り込みが禁止されていたら処理が終わった後も禁止したいし，元々許可されていたら許可したいのです．
このようにしておくことで，どこで割り込みが禁止されていて，どこで許可されているのかを明確に区別できるようになります．

じゃあどうすればいいのか．ようは割り込み許可フラグの値を一旦どこかに保存しておいてからCLIして，処理が終わったら割り込み許可フラグの値を保存しておいたものに戻せばよいのです．
で，割り込み許可フラグがどこにあるかなのですが，これはEFLAGSという特殊なレジスタの第9bitにあります．
EFLAGSというのは32bitのフラグレジスタという部類のもの(元々16bitのFLAGSで，例によって拡張されてEがついた)で，各bitがそれぞれ特殊な意味を持っています．

例えばJCやJEのような，前のCMPなどの命令の結果によってジャンプしたりしなかったりする条件ジャンプ命令というものがありましたが，実はあれは，演算した結果が桁上がりしていたらEFLAGS内のCF(キャリーフラグ)を立てるなどしておいて，条件ジャンプ命令の実行時にEFLAGS内のフラグをチェックしてフラグが立っていたらジャンプする，のようにして実現されていたのです．

というわけで，例のごとくアセンブラでEFLAGSを読み書きする関数，```int io_load_eflags()```,```void io_store_eflags(int eflags)```を作り，それを処理の前後で呼び出すことで，割り込み許可フラグの復元を行っています．

<details><summary>EFLAGSの読み書き</summary>
EFLAGSの読み書きをしたいわけですが，残念ながら<code>MOV EAX,EFLAGS</code>や<code>MOV EFLAGS,EAX</code>のような命令は存在しません．
ではどうするのかというと，PUSHFD/POPFDという命令を使います．
PUSHFDというのはpush flags double-wordの略で，ようは<code>PUSH EFLAGS</code>ということです．
同じようにPOPFDはpop flags double-wordで，<code>POP EFLAGS</code>という意味です．
PUSH/POPというのはスタックに関する命令です．
スタックというのはデータ構造の一種で，データを積み上げて保存しておく，というものです．
具体的には，PUSHするとESPレジスタがデータのバイト数だけ減り，[ESP]番地にデータが代入されます．
そして，POPでは[ESP]番地から値を持ってきてターゲットに代入し，ESPをデータのバイト数だけ増やします．
このようにして値を積んだり持ってきたりする，というのがスタックというデータ構造です．
実はC言語用の関数で[ESP+4*n]番地にn番目の引数が入っていたのは，C言語の関数呼び出しでは引数(32bitなので4バイト)をスタックに積んでから関数をCALLする，という決まりがあったからなのです．

なので，<code>io_load_eflags</code>ではPUSHFDしてEFLAGSの値をスタックに積んでからそれをEAXにPOP(EAXは返り値となる)，
<code>io_store_eflags</code>では第一引数の[ESP+4]の値をスタックにPUSHして，POPFDで値をEFLAGSにPOPする，ということをしています．
</details>

割り込みを禁止ししたので，次に0x03c8にパレット番号(色番号)を書き込みます．
C言語で```io_out8(0x03c8, start);```となっている部分ですね．
naskfunc.nasで```io_out8```を見てみると，これは```OUT 0x03c8, start```に相当することが分かります．

OUT命令というのは何かというと，(CPUから見て)外部の装置に電気信号を送る命令です(これとは逆に，外部の装置から電気信号を受け取るINという命令もあります)．
このOUT命令では，装置番号と送信するデータを指定します．
ここでいうと，0x03c8が装置番号で，startがデータですね．
装置番号0x03c8の装置は一体なんなのかというと，先程のサイトに書いてあるように「ビデオDAコンバータ」という装置のものなのです．
ようはこの装置がパレットを持っていて，その装置に対して命令することでパレットが設定できる，ということですね．

設定する色番号を書き込んだので，次は色を設定していきます．
コンピュータの世界では色を設定する時に，大抵RGBというやつを使います．
RGBはRed,Blue,Green，つまり三原色のことで，それぞれの輝度を設定することで様々な色が表現できます．
で，今回は色を設定するにあたってRGBを一つ一つ0x03c9に書き込んでいけばいい，ということですね．

というわけで，後は0x03c9に延々とRGB成分を書いていけばよいのですが，このRGB成分は```*rgb```，つまり```void init_palette(void);```内の```static unsigned char table_rgb[16 * 3] = {...}```に一気に書いてあります．
そして，その成分をfor文で順番に```io_out8```で0x03c9に書く，ということをしています．
こうしておけば，16*3回も```io_out8```を呼び出す処理を書かなくていい(あと，設定する色の個数も自由に変えられる)ですからね．
ちなみに，staticという指定は，データをスタックではなくデータ領域にDBで置いてもらうための指定です(bootpack.lstを見ると確かにDBになっています)．

あと，色成分を書き込む時に4で割っている理由ですが，これは「0x03c9 : データレジスタ」のところを見ると分かります．
```
bit0-7：RGB成分の一つ（0～63）
	書き込むときは上位2ビットを0に、読み込むときは上位2bitを0と見なす
```
そう，設定できる色成分は実質 8-2 = 6bit なんですね．
じゃあなんで4で割っているんだ，ということなんですが，2進数において2*nで割るというのは右にn bitシフトする，ということになるんです．
例えば0b1000は8ですが，これを右に1bitシフトすると0b0100 = 4で，2bitシフトすると0b0010 = 2になります．
こうすることで上位2bitを0にしている，というわけです．

さて，これで説明は終わりですが，これらのVGAの動作が気になる人は[こちらのサイト](http://softwaretechnique.jp/OS_Development/Tips/VGA/vga04-06.html)などを見てみるとよいでしょう．
