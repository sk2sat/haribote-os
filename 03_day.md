# 3-1 さあ本当のIPLを作ろう
まず，名前がhelloosからはりぼてOSに変わりましたのでよろしくお願いしますはい．
今までのIPLはなんのプログラムもロードしていなかったので，します．

とりあえずプログラムのロードということでブートセクタの次の１セクタ(512バイト)を読み込んでみましょう．
どうやってプログラムをロードするのかというと，文字出力の時と同じく[BIOSファンクション](http://oswiki.osask.jp/?(AT)BIOS )を使います．

フロッピーディスクを使っているので，ドライブは懐かしのAドライブ，読み込みなのでAH=0x02，シリンダ，ヘッドはそれぞれ0，セクタは2です．
読み込み先のメモリアドレスであるバッファアドレスはES:BXなので，```ES*16+BX```が実際のアドレスになります．
EBXとかの32bitレジスタが使えれば話は速いのですが，この仕組みは32bitレジスタなんてものが存在しなかった時代に出来たものなので，このようにして1MBまでのアドレスを指定します．
このようにアドレスの(広域な)指定に使うESのようなレジスタのことをセグメントレジスタといいます．
実は普通にMOVとかの命令を使っているときにもセグメントレジスタというのは使われていて，何も指定していないときはDSが使われています．だからDSにはまっさきに0x00を入れていたんですね．
あと，実行する命令のアドレスを指すプログラムカウンタであるIPも，それだけでは実際のアドレスではなく，CS:IPが実際のアドレスだったりします．
ここらへんの話は，本や[この記事](http://softwaretechnique.jp/OS_Development/bootloader7.html)などが分かりやすいでしょう．

# 3-2 エラーになったらやり直そう
JNC:
	jump if not carry
	carryはキャリーフラグのこと．
JAE:
	jump if above or equal
	大きいかもしくは等しければジャンプ

AH=0x00,DL=0x00でのINT 0x13は「(ディスクの)システムのリセット」

# 3-3 18セクタまで読んでみる
JBE:
	jump if below or equal
	小さいかもしくは等しければジャンプ

次のセクタを読むのに必要なことは，CL(=セクタ番号)を1足すことと，ESを512/16増やすこと．
まあバッファアドレスはES*16+BXなので，BX+=512の方がラクですがそれは本の都合です．
あと，これって実はループにする必要はなくて，ALを17にしておけば「処理するセクタ数」が17，つまりセクタ2〜18が読み込めていいじゃないか，というかんじなんですが，(おそらくフロッピーの場合は)複数のトラックにまたがっていたり，64KB境界を超えたりするとダメみたいなのでループになっています(これからどんどん読み込んでいくので)．

# 3-4 10シリンダ分を読んでみる
JB:
	jump if below
	小さければジャンプ

EQUはnaskの命令で，定数が宣言できる(Cなどにおけるdefineのようなもの)．
CYLSは読み込むシリンダ数．
前回書いた注意があるので，ちゃんと1セクタずつ読み込んでいます．

# 3-5 OS本体を書き初めてみる
さあやってきましたよこの時が！
ようやくブートローダー卒業の兆しが見えてきました．

というわけで，まずは何もしないharibote.sysを作ります．
作り方は，
```
fin:
	HLT
	JMP	fin
```

というharibote.nasを作ってnaskでアセンブルするだけです．超簡単ですね．

で，これでOS本体(空っぽだけれど)が出来たので，これをディスクイメージに保存します．
これは，edimgのコマンドで
```
copy from:haribote.sys to:@:
```

とかやると出来ます．
さて，これで```make img```するとharibote.sysが入ったharibote.imgが生成されるので，中身を見てみましょう．
どうやって中身を見るかといえば，最初に使ったバイナリエディタです．
んでもってこのバイナリをウワーッと眺めていくと，0x2600あたりに```HARIBOTESYS```とかいうなんかそれっぽい文字列があります．
これはファイル名ですね．
じゃあファイルの中身はどこにあるのかというと，```haribote.lst```を見ると，```F4 EB FD```とか書いてあるのでこれを探せばいいのです．
で，これは0x4200あたりにあります．
まあhexeditではEnter押すと指定のアドレスに移動出来るのでものぐさな人はそれで確かめてみると良いでしょう．

というわけで，haribote.sysのアドレスが分かりました．
つまり，あとはこのアドレス(正確にはディスク上でこのアドレスにあったデータが読み込まれた先のアドレス)にジャンプしてしまえば，haribote.sysが実行出来るはずです．
