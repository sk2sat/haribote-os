# 3-1 さあ本当のIPLを作ろう
まず，名前がhelloosからはりぼてOSに変わりましたのでよろしくお願いしますはい．
今までのIPLはなんのプログラムもロードしていなかったので，します．

とりあえずプログラムのロードということでブートセクタの次の１セクタ(512バイト)を読み込んでみましょう．
どうやってプログラムをロードするのかというと，文字出力の時と同じく[BIOSファンクション](http://oswiki.osask.jp/?(AT)BIOS )を使います．

フロッピーディスクを使っているので，ドライブは懐かしのAドライブ，読み込みなのでAH=0x02，シリンダ，ヘッドはそれぞれ0，セクタは2です．
読み込み先のメモリアドレスであるバッファアドレスはES:BXなので，```ES*16+BX```が実際のアドレスになります．
EBXとかの32bitレジスタが使えれば話は速いのですが，この仕組みは32bitレジスタなんてものが存在しなかった時代に出来たものなので，このようにして1MBまでのアドレスを指定します．
このようにアドレスの(広域な)指定に使うESのようなレジスタのことをセグメントレジスタといいます．
実は普通にMOVとかの命令を使っているときにもセグメントレジスタというのは使われていて，何も指定していないときはDSが使われています．だからDSにはまっさきに0x00を入れていたんですね．
あと，実行する命令のアドレスを指すプログラムカウンタであるIPも，それだけでは実際のアドレスではなく，CS:IPが実際のアドレスだったりします．
ここらへんの話は，本や[この記事](http://softwaretechnique.jp/OS_Development/bootloader7.html)などが分かりやすいでしょう．

# 3-2 エラーになったらやり直そう
JNC:
	jump if not carry
	carryはキャリーフラグのこと．
JAE:
	jump if above or equal
	大きいかもしくは等しければジャンプ

AH=0x00,DL=0x00でのINT 0x13は「(ディスクの)システムのリセット」

# 3-3 18セクタまで読んでみる
JBE:
	jump if below or equal
	小さいかもしくは等しければジャンプ

次のセクタを読むのに必要なことは，CL(=セクタ番号)を1足すことと，ESを512/16増やすこと．
まあバッファアドレスはES*16+BXなので，BX+=512の方がラクですがそれは本の都合です．
あと，これって実はループにする必要はなくて，ALを17にしておけば「処理するセクタ数」が17，つまりセクタ2〜18が読み込めていいじゃないか，というかんじなんですが，(おそらくフロッピーの場合は)複数のトラックにまたがっていたり，64KB境界を超えたりするとダメみたいなのでループになっています(これからどんどん読み込んでいくので)．

# 3-4 10シリンダ分を読んでみる
JB:
	jump if below
	小さければジャンプ

EQUはnaskの命令で，定数が宣言できる(Cなどにおけるdefineのようなもの)．
CYLSは読み込むシリンダ数．
前回書いた注意があるので，ちゃんと1セクタずつ読み込んでいます．

# 3-5 OS本体を書き初めてみる
さあやってきましたよこの時が！
ようやくブートローダー卒業の兆しが見えてきました．

というわけで，まずは何もしないharibote.sysを作ります．
作り方は，
```
fin:
	HLT
	JMP	fin
```

というharibote.nasを作ってnaskでアセンブルするだけです．超簡単ですね．

で，これでOS本体(空っぽだけれど)が出来たので，これをディスクイメージに保存します．
これは，edimgのコマンドで
```
copy from:haribote.sys to:@:
```

とかやると出来ます．
さて，これで```make img```するとharibote.sysが入ったharibote.imgが生成されるので，中身を見てみましょう．
どうやって中身を見るかといえば，最初に使ったバイナリエディタです．
んでもってこのバイナリをウワーッと眺めていくと，0x2600あたりに```HARIBOTESYS```とかいうなんかそれっぽい文字列があります．
これはファイル名ですね．
じゃあファイルの中身はどこにあるのかというと，```haribote.lst```を見ると，```F4 EB FD```とか書いてあるのでこれを探せばいいのです．
で，これは0x4200あたりにあります．
まあhexeditではEnter押すと指定のアドレスに移動出来るのでものぐさな人はそれで確かめてみると良いでしょう．

というわけで，haribote.sysのアドレスが分かりました．
つまり，あとはこのアドレス(正確にはディスク上でこのアドレスにあったデータが読み込まれた先のアドレス)にジャンプしてしまえば，haribote.sysが実行出来るはずです．

# 3-6 ブートセクタからOS本体を実行させてみる
さて，あとは今ディスクイメージ上で0x4200にいるharibote.sysを実行すればいいだけです．
じゃあharibote.sysが今メモリ上どこにいるのかといえば，現状のIPLだとブートセクタの先頭が0x8000に来るようにディスクを読んでいるので，
0x8000+0x4200=0xc200にいるはずです．
さて，ここまで分かったら簡単です，0xc200にジャンプしてしまえば良いのです．

# 3-7 OS本体の動作を確認してみる
OS本体がちゃんと起動できたか確認するために，OSにちょっと芸をさせます．
とりあえず画面モード変更です．

画面モードの変更は，例によってBIOSの力を借ります．
文字を表示するときにint 0x10を使いましたよね，あれです．
で，[ここ](http://oswiki.osask.jp/?(AT)BIOS )を見ると，画面モードの変更はAH=0x00,ALにモード毎の番号を入れてやればいいみたいです．
画面モードは8bitカラーな0x13にしておきましょう．
画面が真っ黒になったら成功です．
あと，IPLの名前をipl10.nasにしておきましょう10シリンダしか読み込んでないので．

# 3-8 32ビットモードへの準備
はい，そのうち32ビットモードで開発をすることになるのでその準備です．
なんで32ビットモードにするのかというと，これから使うC言語に都合が良かったりとか，CPUの保護機能が使えたりしてとても良いので32ビット(プロテクト)モードにしたいのです．

32ビットモードと言っていますがじゃあ今は何ビットモードなんだよ，というと実は16ビット(リアル)モードです．
16ビットモードでは今まで使ってきたAXとかの16ビットのレジスタが使えます．
となるともう予想はつきますが，32ビットモードでは32ビットのレジスタが使えます．
これによりメモリが1MBを大きく超えてアクセス出来ます！素晴らしいですね．
あまりにも素晴らしかったので32ビットCPUを作った人たちはレジスタにextend(拡張)のEをつけました．
<s>あれ．．．？AXとかのXもextendでは．．．？</s>
というわけで32ビットモードではレジスタはEAXとかECXとかいう名前になります．
これはAXとかの時と同じように拡張されただけなので，EAXの下位16ビットがAX,その下位8ビットがAL，というかんじです．
もちろんAXに何らかの値を代入したらEAXの下位16ビットも変わります．


で，32ビットモードは利点が多いのでさっさと使いたいんですが，なんと16ビットモードと32ビットモードでは機械語の種類が違います．
どういうことかというと，全く同じバイナリをそれぞれのモードに食わせたら全然違う解釈をしてしまいます(まあ，8ビット系の命令は結構共通だったりはしますが)．
これで何が困るかというと，今まで困った時の神頼み的に使っていたBIOS様が使えなくなってしまいます．
彼は16ビット用に書かれているので．．．

こんな事情があるので，32ビットモードにする前にBIOSに頼んでやっておきたいことはやってしまっておこう，というのが「準備」の内容です．

VRAM:
	Video RAM
	メモリの一部．ディスプレイと繋がっていて，それぞれの番地が画面上の画素に対応している．

# 3-9 ついにC言語導入へ
さあさあ，ようやくC言語ですよ．
つまり，32ビットに切り替えてアセンブラとはおさらば，です．
ただ，32ビットに切り替えたりC言語の部分を呼び出すための前処理についてはアセンブラでしか書けないのでアセンブラで書いて，asmhead.nasとします．
C言語の部分は，とりあえず何もしないメイン関数を作って，bootpack.cとします．
で，あとはこれらをバイナリにしてくっつけて，あとは今までと同じようにedimgでイメージファイルに入れてあげれば大丈夫です．

というわけでまずはasmheadなのですが，ちょっと面倒なことをやっているので実は解説が8日目あたりにようやく生えてきたりします．
まあ何をやているかというと，

* PICの割り込み禁止
* A20GATE信号線をONにする(これでメモリが1MB以上使えるようになる！)
* 暫定GDTの設定
* ページング禁止
* 32ビットプロテクトモード移行
* bootpackの転送
* bootpackの起動

わー．いっぱいありますねー(白目)．
まあ，「自作OSで一番大変なのはブート」とも言いますし，しょうがないんですけどね．

ああ，あと今回のasmheadではアセンブラで関数を作っています．
CALLとRETってやつです．
CALLは今いる番地をスタックにメモしてJMPする命令で，RETはスタックから番地を取ってきてそこにJMPする命令です．
これで，関数の最後にRETを入れておけば，CALLして使うとちゃんと処理が終わった後に戻ってこられるわけですね．

これでようやくC言語なんですが，コンパイルの手順がﾁｮｯﾄ面倒です．

.c	=> cc1		=> .gas
.gas	=> gas2nask	=> .nas
.nas	=> nask		=> .obj
.obj	=> obj2bim	=> .bim
.bim	=> bim2hrb	=> .hrb

左と右のは拡張子，真ん中のはツール名です．
実行オプションなどはMakefileから察して下さい．

# 3-10 とにかくHLTしたい
はい．とにかくHLTしたいんです．
C言語ではHLTすることは出来ないんですよね．普通はする必要も無いですし．

でも，HLTしないで無限ループするのは電気がもったいないです．なのでHLTしましょう．

じゃあどうするのかというと，アセンブラで関数を作ります．
asmheadのmemcpyとかと同じですね．最後にRETをつけてCALLでそこの番地を指定してやればいいわけです．
ただ，C言語から呼び出すためにはちょっと工夫が必要です．

まず，アセンブラで関数を作ってもCコンパイラはそんなことを知る由もないので，それを教えてあげなければいけません．
そこで，Cのソースコードで関数の中身を書かずに，宣言だけを行います．
これは関数のプロトタイプ宣言といって，分割コンパイルを行う時などによく使われます．

あとは，用意した関数プロトタイプとアセンブラで作った関数が結び付けられれば良い訳ですね．
そのため，アセンブラを生のバイナリではなく，オブジェクトファイルにアセンブルします．
これはC言語をコンパイルする手順で出てきた.objと同じもので，バイナリ，関数名，関数のアドレスなどの情報が集まっているファイルです．
このようにしておくと，関数の宣言だけをしておいて，他のオブジェクトファイルとくっつけた時に関数の実装をちゃんと参照する，みたいなことが出来る訳です．

オブジェクトファイルをくっつけることをリンクといい，これを行うプログラムのことをリンカと言います(ここではobj2bim)．

naskでオブジェクトファイルを作るには```[FORMAT "WCOFF"]```を指定します．
WCOFFというのはwin32-COFFのことで，まあようするにWindowsでCをコンパイルした時に出てくるアイツです．ELFではありません．

また，オブジェクトファイルで公開する関数は```GLOBAL```で宣言します．

あとはいくらでもアセンブラで関数を作ってCから使うことが出来ますね．
OS開発ではどうしてもCで書けない部分というのが結構あるので，これからもアセンブラで関数を作る機会は割とあります．
